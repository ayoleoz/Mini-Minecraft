Milestone1:
Tianze ZHENG: Game Engine Tick Function and Player Physics
Tianyuan DAI: Procedural Terrain
Tianle DING: Efficient Terrain Rendering and Chunking

Tianyuan DAI:
I use worley noise to generate the raw mountain height. I use fbm2D to generate the raw grassland height. For the third noise function, I use perlin noise. Frequencies of these noise functions are tuned to be 64, 128 and 50 respectively. To improve in the future, I may consider using a composite noise function. 

Tianle DING: 
To draw the chunks,I choose to create vertex data to be sent to the VBO of a chunk in Terrain class, to avoid finding blocks from a neighbour Chunk in Chunk class when we want to exclude data for faces of blocks hidden by another block.Then, these data are sent to a single VBO buffer and an IDX buffer allocated on a graphic card, then the shaderprogram sets its model as position of the chunk, and uses a modified function to read from the single buffer and IDX buffer to draw the chunk.
For terrain generation check, in each tick, 5*5 chunks around the player is checked whether they exists, if they do not exist, then the terrain class should generate its block types,  after generating all chunks nearby, another function is called in terrain if 3*3 chunks around the player have its VBO data generated, if they don’t, then VBO data for these chunks are created. This is to make sure that the 3*3 chunks near the player is appropriately displayed on the screen, while 5*5 chunks around the player have already been created(a mimic of what we need to do in milestone 2).
In addition, to simplify adding blocks in the future, a structure called vertex data and a map from block type to vertices’ color is used.

Tianze ZHENG: 
Game Engine Tick Function and Player Physics:
For player's inputs, I edited entity.h to add more key-pressed buttons and edited key and mouse events in myGL.cpp to update m_inputs every time a key is pressed or a mouse is clicked. By doing so, the game engine can rotate the camera on mouse movement, enable or disable flightMode, move in 3D directions, and add/remove blocks on mouse clicks. In the player.cpp input processing function, I just match the key pressed with the direction that I want to associate the key with. Then I add accelerations to the speed and also detect if the player is in the flightMode. If not, then if the player is in the sky, then a gravity will be applied to the acceleration. In the computePhysics function, I update the player's position based on the acceleration and velocity calculated from the previous function by multiplying the velocity by a certain factor (0.95) and adding the accelerations.
For collision detection, I create another function called collision detection and use ray casting to check if there are any blocks in the rayDirection. I multiply the outDist by a factor of 0.999 to smooth the collision process. Right now instead of updating rayDirection by multiplying it with the minimum distance calculated, I just set it to glm::vec3(0) because of the debugging issue. I will come back and fix it in the next milestone.
For placing and removing blocks, I use ray casting to check if there are any blocks within 3 units of the player. If there are any blocks overlapping with the center of the screen, I then set the block to STONE if the mouse is right-clicked or EMPTY if left-clicked.
For the tick function, I invoked Player::tick from MyGL::tick and calculated dT using QDateTime::currentMSecsSinceEpoch() to make the movements smoother.


Milestone2:
Tianze ZHENG: Multithreaded Terrain Generation
Tianyuan DAI: Cave Systems
Tianle DING: Texturing and Texture Animation

Tianyuan DAI:
For cave generation, I extend perlin noise to 3d perlin noise. For each (x, y, z), I plug in the coordinate into the 3d perlin noise function. If the noise output is negative, I set the block to EMPTY. 
For swimming in the water when pressing space bar, I add member variable isInWater to the player class. I check whether the player is in water every iteration and set isInWater to true or false. If it is true, I set the speed of the player to a small value when pressing space bar.
For allowing the player to fall into the water or lava, I modify the collision detection function. When the player is not in the flight mode, we view WATER and LAVA as EMPTY and continue the original logic.
For tinging the screen to blue when the player is in water and tinging the screen to red when the player is in lava, I set up the post process pipeline. I extended the shaderProgram class, and added frameBuffer, quad, postShaderProgram classes, and implemented passthrough vertex shader and noOp, redTint, blueTint fragment shaders. By adding isInWater and isInLava attributes to the player class and update them every iteration, I could know whether the player is in water or lava. In initializeGL(), I create quad, and three required post shader programs. In resizeGL(), I resize the three required post shader programs. In paintGL(), I first render terrain, in which I bind frame buffer. Then I perform post process in paintGL(), in which I send the drawn scene to the slot.  

Tianle Ding:
For texturing, I load the texture png and do most operations about texturing on the CPU side with the class Texture, which is copied from HW4. UV data for each face of blocks is stored in constant maps that map faces of blocks to UV coordinate and map vertices  on the face to some offset. From there I can refer to the UV coordinate of each vertex of some triangle when creating VBO data. VBO data is stored in a structure called VertexData, where I store position, normal and UV for one single vertex, while a vector of such VBO data is sent to the GPU buffer along with the index buffer. By doing this, I can store each UV as a vec2 on the GPU side buffer, instead of a vec4. A sampler is set in the fragment shader of lambert to sample the texture according to the fragment UV, interpolated from vertex UV in vertex buffer. Then I send an integer representing time to the GPU fragment shader. Once the GPU finds that it should sample the texture of water or lava, it adds an offset related with time to the UV coordinate, so that I can create an animated texture for water and lava. The offset is fractured and then floored to create a noncontinuous minecraft-like animation effect. Then I modify the VBO data creation function so that faces next to a transparent block should be drawn, and faces of  transparent blocks are stored in another buffer in addition to the buffer for opaque faces. Then the shaderprogram and draw function in Terrain class is also modified so that all opaque faces are drawn first, only after that can we draw the transparent faces. 

Tianze ZHENG: 
For the multi-threading part, the terrain expansion function checks the surrounding 5x5 terrain zones each frame to see whether there are blocks that have been set up or not. If not, then I get a thread to set blocks up. If the blocks already exist, then I am going to spawn a thread to create VBO Data for them. On the main thread, I send VBO data to the GPU to draw all the blocks and at the same time destroying all the blocks' VBO data for those chunks that are too far away from the player for efficiency. The hard part for me is to understand the concept of Mutex and Threads and also how different parts of the program communicates with each other. I find the professors’ lecture on multi-threading and the sample code provided very helpful.


Milestone3:
Tianze ZHENG: Day and night cycle, Distance fog
Tianyuan DAI: Procedural grass color, Water waves, Post-process Camera Overlay
Tianle DING: Shadow mapping

Tianyuan DAI:
(Post-process Camera Overlay):
I first generate the wave and distort the player’s view when the player is under water or under lava. Then, I use clamp(a + b * cos(2.0 * 3.14159 * (c * t + d)), 0.0, 1.0) to help generate red tint or blue tint, where a, b, c and d are self-defined constants. The above are inspired by and are a combination of shaders at https://www.shadertoy.com/view/WsSGDw and https://www.shadertoy.com/view/4slBWN. 
(Procedural grass color):
I modify the lambert fragment shader to generate procedural grass colors. First, I check for grass texture. Then I call the function biomeGrassGreen() to get vec4 green color. And use the green color to multiply diffuseColor to get the new diffuseColor. Inside biomeGressGreen, I define three different grass greens. Then I use perline noise to interpolate between the three colors to get a new green returned.
(Water waves):
For water waves, I add to the lambert vertex shader. First, I check for water blocks. Then, if it is, I combine different scales of sine waves to define a distance. I subtract that distance from the original y position to create a wave effect.
And I also implement the Blinn-Phong shader. I add unifCamPos in the shaderprogram class. And I implement setCamPos() function as a member function of the shaderprogramm class. I call m_progLambert.setCamPos(m_player.mcr_camera.mcr_position) inside MyGL::paintGL() to set up camera position of the shader programm m_progLambert. Then, inside lambert vertex and shader program, I just check for water texture and imitate the way I implement the Blinn-Phong shader in HW4.

Tianle Ding:
For shadow mapping, I first draw terrain around the player with a radius slightly larger than rendering radius(to avoid visual errors) using a special shadow shader, which has a large orthographic camera directing from the direction of the sun to the player, this shader do not draw anything on screen, but the z data for each fragment is buffered in a frame buffer. Besides, transparent blocks are not considered(drawn) in shadow shader to make them also transparent to shadow.
Then I use this buffer as a texture in lambert, the buffered z data is used to compare with the z data relative to the same orthographic camera for every fragment in lambert, and these fragments with a larger z than the buffered shadow texture are drawn darker. And I also used surface normal related bias and Poisson Sampling with 16-time sampling to remove shadow acne and soften the edges. To cooperate with the day-night cycle, I made my sun direction the same as it is claimed in day-night cycle, to make a more realistic shadowing effect. For critical time points like dusk, noon and sunset, I interpolate between my shadow value and some designated value to make a visually continuous light effect. 

Tianze ZHENG: 
For inventory, I designed another ui page and attach png images for showing purpose. I used radio button and QLCDNumber for selecting different BlockTypes and keeping track of the remaining number. The inventory UI page will show up after pressing I and the users can select the BlockType with their mouse (the mouse is needed to be shown by switching to the inventory window from the main window). The remaining number of the BlockTypes is updated through setNum(BlockType) functions inside the inventory.cpp, and similarly for setting the current BlockType function as well. I think the difficulty for this task is the part where I have to modify the return type of placeBlock and removeBlock functions inside player.cpp, in such a way that I can know which BlockType to be modified inside mygl.cpp. After placing a block, the remaining number will decrease by one, and after breaking it (removing it), the number will increase by one. And also there is something weird with the display of the inventory UI page, as the png images are not shown as expected, but this does not influence the basic functionality of the inventory system.  

For the day and night cycle, I build based on the code that was given in the course website, and start from there to change several things. I change the position of the sun over time so that it could rotate around the world as the day and the night cycle switches. I add a new palette for the color of the sun to make it more realistic in the daytime. The reytracing code is used to calculate the value of the colors based on the rays point from the player. The output color is calculated by putting spherical uvs on the quad. The effect of the sun and the "dusky-colored father away from the sun" is done by interpolating and mixing values of the sun and dusk. In the lambert fragment, the direction of the sun light is set in such way that mimics the actual sunlight with Lambert shading.
